package com.backendrumba.rumba_music.controller;import com.backendrumba.rumba_music.model.Song;import com.backendrumba.rumba_music.model.User;import com.backendrumba.rumba_music.service.SongService;import com.backendrumba.rumba_music.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.io.ByteArrayResource;import org.springframework.core.io.Resource;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import java.io.IOException;import java.time.LocalDateTime;import java.util.List;import java.util.Optional;@RestController@RequestMapping("/api/songs")public class SongController {    @Autowired    private SongService songService;    @Autowired    private UserService userService;    // Endpoint para subir una canción (solo DJs o ADMIN)    @PostMapping("/upload/{userId}")    public ResponseEntity<String> uploadSong(@RequestParam("file") MultipartFile file, @PathVariable Long userId) {        try {            String fileName = songService.saveSong(file, userId);            return new ResponseEntity<>("Canción " + fileName + " subida correctamente.", HttpStatus.OK);        } catch (RuntimeException | IOException e) {            return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST);        }    }    // Endpoint para obtener todas las canciones subidas por un DJ o ADMIN    @GetMapping("/dj-admin/{userId}")    public ResponseEntity<List<Song>> getSongsByDJOrAdmin(@PathVariable Long userId) {        try {            List<Song> songs = songService.getSongsByDJOrAdmin(userId);            return new ResponseEntity<>(songs, HttpStatus.OK);        } catch (RuntimeException e) {            return new ResponseEntity<>(null, HttpStatus.BAD_REQUEST);        }    }    // Obtener una canción por su ID    @GetMapping("/{id}")    public ResponseEntity<Song> getSongById(@PathVariable Long id) {        Optional<Song> song = songService.getSongById(id);        if (song.isPresent()) {            return ResponseEntity.ok(song.get());        } else {            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();        }    }    // Obtener todas las canciones    @GetMapping    public ResponseEntity<List<Song>> getAllSongs() {        List<Song> songs = songService.getAllSongs();        return ResponseEntity.ok(songs);    }    // Eliminar una canción por su ID    @DeleteMapping("/{id}")    public ResponseEntity<String> deleteSong(@PathVariable Long id) {        try {            songService.deleteSong(id);            return ResponseEntity.ok("Canción eliminada correctamente.");        } catch (Exception e) {            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Error: " + e.getMessage());        }    }    // Reproducir una canción por su ID    @GetMapping("/play/{id}")    public ResponseEntity<Resource> playSong(@PathVariable Long id) throws Exception {        try {            // Obtener el recurso de la canción desde la base de datos (usando el campo BLOB)            Resource resource = songService.getSongFile(id);            // Devolver la canción como respuesta            return ResponseEntity.ok()                    .contentType(MediaType.parseMediaType("audio/mpeg"))                    .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + id + ".mp3\"")                    .body(resource);        } catch (RuntimeException e) {            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ByteArrayResource(e.getMessage().getBytes()));        }    }}